-- ============================================================================
-- 운영 기준 스키마 (Supabase/PostgreSQL)
-- 핵심 원칙:
-- 1) RLS 기본 적용
-- 2) FK/제약/인덱스로 무결성과 성능 확보
-- 3) 소셜 공유는 "돌 정의 데이터"를 저장하고 렌더는 재생성
-- ============================================================================

-- [0] 공통 유틸 함수
create or replace function public.set_updated_at()
returns trigger
language plpgsql
security invoker
set search_path = public
as $$
begin
  new.updated_at = now();
  return new;
end;
$$;

create or replace function public.kst_week_start(ts timestamp with time zone)
returns date
language sql
immutable
set search_path = pg_catalog
as $$
  select date_trunc('week', ts at time zone 'Asia/Seoul')::date;
$$;

-- [1] 유저 프로필 (지갑 역할)
create table if not exists public.profiles (
  id uuid primary key references auth.users(id) on delete cascade,
  nickname text not null default '돌키우기초보',
  minerals jsonb not null default '{"stone": 100}'::jsonb,
  created_at timestamp with time zone not null default now(),
  updated_at timestamp with time zone not null default now(),
  constraint profiles_nickname_len_chk check (char_length(nickname) between 1 and 32),
  constraint profiles_minerals_obj_chk check (jsonb_typeof(minerals) = 'object')
);

drop trigger if exists trg_profiles_updated_at on public.profiles;
create trigger trg_profiles_updated_at
before update on public.profiles
for each row execute function public.set_updated_at();

-- [2] 광물 레시피 (정적 데이터)
create table if not exists public.mineral_recipes (
  id int generated by default as identity primary key,
  name text not null unique,           -- 예: Hematite
  formula text not null,               -- 예: Fe2O3
  elements jsonb not null,             -- 예: {"Fe": 2, "O": 3}
  dna jsonb not null default '{"system":"unknown"}'::jsonb, -- 렌더 재생성용 정본 파라미터
  crystal_system text not null default 'unknown', -- triclinic/monoclinic/orthorhombic/tetragonal/trigonal/hexagonal/cubic 등
  base_density double precision not null check (base_density > 0),
  base_color text not null default '#ffffff',
  pm_ids int[] not null default '{}',                    -- Paragenetic Mode 번호 목록 (추적/검증용)
  gacha_weight double precision not null default 1.0 check (gacha_weight > 0),  -- 원소 뽑기 확률 가중치
  created_at timestamp with time zone not null default now(),
  updated_at timestamp with time zone not null default now(),
  constraint recipes_elements_obj_chk check (jsonb_typeof(elements) = 'object'),
  constraint recipes_dna_obj_chk check (jsonb_typeof(dna) = 'object'),
  constraint recipes_dna_has_system_chk check (dna ? 'system'),
  constraint recipes_crystal_system_chk check (
    lower(crystal_system) in (
      'triclinic',
      'monoclinic',
      'orthorhombic',
      'tetragonal',
      'trigonal',
      'hexagonal',
      'cubic',
      'amorphous',
      'unknown'
    )
  ),
  constraint recipes_crystal_system_match_dna_chk check (lower(crystal_system) = lower(dna->>'system'))
);

-- 기존 환경(이전 스키마)에서 마이그레이션 시 컬럼 보강 (dna 정본, pm_ids, gacha_weight)
alter table public.mineral_recipes
  add column if not exists dna jsonb,
  add column if not exists crystal_system text,
  add column if not exists pm_ids int[] default '{}',
  add column if not exists gacha_weight double precision default 1.0;

alter table public.mineral_recipes
  drop constraint if exists recipes_crystal_structure_obj_chk;

alter table public.mineral_recipes
  drop column if exists crystal_structure;

alter table public.mineral_recipes
  alter column dna set default '{"system":"unknown"}'::jsonb,
  alter column crystal_system set default 'unknown',
  alter column base_color set default '#ffffff';

update public.mineral_recipes
set crystal_system = lower(coalesce(crystal_system, dna->>'system', 'unknown'));

update public.mineral_recipes
set dna = case
  when dna is null then jsonb_build_object('system', lower(crystal_system))
  when jsonb_typeof(dna) <> 'object' then jsonb_build_object('system', lower(crystal_system))
  else jsonb_set(dna, '{system}', to_jsonb(lower(crystal_system)), true)
end;

alter table public.mineral_recipes
  alter column dna set not null,
  alter column crystal_system set not null;

do $$
begin
  if not exists (
    select 1
    from pg_constraint
    where conname = 'recipes_dna_obj_chk'
      and conrelid = 'public.mineral_recipes'::regclass
  ) then
    alter table public.mineral_recipes
      add constraint recipes_dna_obj_chk
      check (jsonb_typeof(dna) = 'object');
  end if;

  if not exists (
    select 1
    from pg_constraint
    where conname = 'recipes_dna_has_system_chk'
      and conrelid = 'public.mineral_recipes'::regclass
  ) then
    alter table public.mineral_recipes
      add constraint recipes_dna_has_system_chk
      check (dna ? 'system');
  end if;

  if not exists (
    select 1
    from pg_constraint
    where conname = 'recipes_crystal_system_chk'
      and conrelid = 'public.mineral_recipes'::regclass
  ) then
    alter table public.mineral_recipes
      add constraint recipes_crystal_system_chk
      check (
        lower(crystal_system) in (
          'triclinic',
          'monoclinic',
          'orthorhombic',
          'tetragonal',
          'trigonal',
          'hexagonal',
          'cubic',
          'amorphous',
          'unknown'
        )
      );
  end if;

  if not exists (
    select 1
    from pg_constraint
    where conname = 'recipes_crystal_system_match_dna_chk'
      and conrelid = 'public.mineral_recipes'::regclass
  ) then
    alter table public.mineral_recipes
      add constraint recipes_crystal_system_match_dna_chk
      check (lower(crystal_system) = lower(dna->>'system'));
  end if;
end
$$;

drop trigger if exists trg_mineral_recipes_updated_at on public.mineral_recipes;
create trigger trg_mineral_recipes_updated_at
before update on public.mineral_recipes
for each row execute function public.set_updated_at();

insert into public.mineral_recipes (name, formula, elements, base_density, base_color, dna, crystal_system)
values
  ('Quartz', 'SiO2', '{"Si": 1, "O": 2}', 60.1, '#e6e6fa', '{"system":"trigonal","notes":"alpha-quartz(typical)"}', 'trigonal'),
  ('Hematite', 'Fe2O3', '{"Fe": 2, "O": 3}', 159.6, '#6a0dad', '{"system":"trigonal","notes":"rhombohedral setting"}', 'trigonal'),
  ('Gold Nugget', 'Au', '{"Au": 1}', 197.0, '#ffd700', '{"system":"cubic","notes":"native gold"}', 'cubic')
on conflict (name) do nothing;

-- [3] 유저 원소 인벤토리 (PRD: 소수점 이하 6자리까지 표현)
create table if not exists public.user_materials (
  id bigint generated by default as identity primary key,
  user_id uuid not null references public.profiles(id) on delete cascade,
  element text not null, -- 원소 기호
  amount numeric(12,6) not null default 0 check (amount >= 0),
  created_at timestamp with time zone not null default now(),
  updated_at timestamp with time zone not null default now(),
  unique(user_id, element)
);

create index if not exists idx_user_materials_user_id on public.user_materials(user_id);

-- 마이그레이션: amount가 int인 기존 DB → numeric(12,6)
do $$
begin
  if exists (select 1 from information_schema.columns where table_schema='public' and table_name='user_materials' and column_name='amount' and data_type='integer') then
    alter table public.user_materials alter column amount type numeric(12,6) using amount::numeric(12,6);
  end if;
end $$;

drop trigger if exists trg_user_materials_updated_at on public.user_materials;
create trigger trg_user_materials_updated_at
before update on public.user_materials
for each row execute function public.set_updated_at();

-- [4] 돌(Stone) 데이터 (개인 인벤토리)
create table if not exists public.stones (
  id bigint generated by default as identity primary key,
  owner_id uuid not null references public.profiles(id) on delete cascade,
  recipe_id int not null references public.mineral_recipes(id) on delete restrict,
  dna jsonb not null default '{}'::jsonb,  -- 외형/불순물 등 절차적 데이터
  name text not null default 'Unnamed Stone',
  birth_date timestamp with time zone not null default now(),
  current_mass double precision not null default 0.0,
  created_at timestamp with time zone not null default now(),
  updated_at timestamp with time zone not null default now(),
  constraint stones_dna_obj_chk check (jsonb_typeof(dna) = 'object'),
  constraint stones_current_mass_chk check (current_mass >= 0)
);

create index if not exists idx_stones_owner_id on public.stones(owner_id);
create index if not exists idx_stones_recipe_id on public.stones(recipe_id);
create index if not exists idx_stones_birth_date on public.stones(birth_date);

drop trigger if exists trg_stones_updated_at on public.stones;
create trigger trg_stones_updated_at
before update on public.stones
for each row execute function public.set_updated_at();

-- [5] 소셜 공유 (돌 자랑)
-- 이미지 파일 저장 없이 stone_definition(정의 데이터)만 저장.
create table if not exists public.shared_stones (
  id bigint generated by default as identity primary key,
  owner_id uuid not null references public.profiles(id) on delete cascade,
  stone_id bigint references public.stones(id) on delete set null,
  stone_definition jsonb not null, -- seed/dna/recipe/trace 등 재렌더 기준 데이터
  title text not null,
  summary text not null default '',
  description text not null default '',
  week_key date not null default public.kst_week_start(now()),
  is_deleted boolean not null default false,
  created_at timestamp with time zone not null default now(),
  updated_at timestamp with time zone not null default now(),
  constraint shared_stones_definition_obj_chk check (jsonb_typeof(stone_definition) = 'object'),
  constraint shared_stones_title_len_chk check (char_length(title) between 1 and 80),
  constraint shared_stones_summary_len_chk check (char_length(summary) <= 120),
  constraint shared_stones_description_len_chk check (char_length(description) <= 2000)
);

create index if not exists idx_shared_stones_owner_id on public.shared_stones(owner_id);
create index if not exists idx_shared_stones_week_key on public.shared_stones(week_key);
create index if not exists idx_shared_stones_created_at on public.shared_stones(created_at desc);
create index if not exists idx_shared_stones_visible_week on public.shared_stones(week_key, is_deleted);

drop trigger if exists trg_shared_stones_updated_at on public.shared_stones;
create trigger trg_shared_stones_updated_at
before update on public.shared_stones
for each row execute function public.set_updated_at();

-- [6] 소셜 반응 (좋아요)
create table if not exists public.stone_likes (
  shared_stone_id bigint not null references public.shared_stones(id) on delete cascade,
  user_id uuid not null references public.profiles(id) on delete cascade,
  created_at timestamp with time zone not null default now(),
  primary key (shared_stone_id, user_id)
);

create index if not exists idx_stone_likes_user_id on public.stone_likes(user_id);
create index if not exists idx_stone_likes_created_at on public.stone_likes(created_at desc);

-- [7] 주간 랭킹 뷰
create or replace view public.weekly_shared_stone_ranking
with (security_invoker = true)
as
select
  s.week_key,
  s.id as shared_stone_id,
  s.owner_id,
  s.title,
  s.summary,
  s.created_at,
  count(l.user_id)::int as likes_count,
  dense_rank() over (
    partition by s.week_key
    order by count(l.user_id) desc, s.created_at asc, s.id asc
  ) as rank
from public.shared_stones s
left join public.stone_likes l on l.shared_stone_id = s.id
where s.is_deleted = false
group by s.week_key, s.id, s.owner_id, s.title, s.summary, s.created_at;

-- [8] 회원가입 트리거 (자동 프로필 생성)
create or replace function public.random_default_nickname()
returns text
language sql
stable
set search_path = pg_catalog
as $$
  select (
    array[
      'Stony Stark',
      'Rock Obama',
      'Jasper Lopez',
      'Rocky Laufeyson',
      'Quickgold',
      'Flint Eastwood',
      'Chalk Norris',
      'Shale Silverstein',
      'Nickel Fury'
    ]
  )[1 + floor(random() * 9)::int];
$$;

create or replace function public.handle_new_user()
returns trigger
language plpgsql
security definer
set search_path = public
as $$
begin
  insert into public.profiles (id, nickname, minerals)
  values (new.id, public.random_default_nickname(), '{"stone": 100}'::jsonb)
  on conflict (id) do nothing;
  return new;
end;
$$;

drop trigger if exists on_auth_user_created on auth.users;
create trigger on_auth_user_created
  after insert on auth.users
  for each row execute function public.handle_new_user();

----------------------------------------------------------------------------
-- [8-2] 원소 뽑기 RPC (스톤 소모 → 가중치 랜덤 광물 → 1회분(300) 원소 지급)
----------------------------------------------------------------------------
create or replace function public.purchase_element_pack()
returns jsonb
language plpgsql
security invoker
set search_path = public
as $$
declare
  uid uuid;
  stone_bal int;
  rec record;
  total_weight float8;
  rnd float8;
  elem text;
  ratio float8;
  sum_ratio float8;
  amt numeric(12,6);
  elements_out jsonb := '{}'::jsonb;
  batch_total float8 := 300;  -- 1회분 기준 총량 (PRD)
begin
  uid := auth.uid();
  if uid is null then
    return jsonb_build_object('status', 'error', 'message', 'Not authenticated');
  end if;

  select (minerals->>'stone')::int into stone_bal from profiles where id = uid;
  if stone_bal is null then
    return jsonb_build_object('status', 'error', 'message', 'Profile not found');
  end if;
  if stone_bal < 100 then
    return jsonb_build_object('status', 'error', 'message', 'Insufficient stone', 'current_stone', stone_bal);
  end if;

  -- 가중치 랜덤으로 광물 1종 선택
  select sum(gacha_weight)::float8 into total_weight from mineral_recipes;
  if total_weight is null or total_weight <= 0 then
    return jsonb_build_object('status', 'error', 'message', 'No recipes');
  end if;
  rnd := total_weight * random();
  select id, name, elements into rec
  from (
    select id, name, elements, sum(gacha_weight) over (order by id) as cum
    from mineral_recipes
  ) t
  where cum >= rnd
  order by cum
  limit 1;
  if rec.id is null then
    select id, name, elements into rec from mineral_recipes order by id desc limit 1;
  end if;

  -- 1회분(300) 비율 배분: elements 비율 합으로 나눠 각 원소량 계산 (PRD: 소수점 이하 6자리)
  sum_ratio := 0;
  for elem, ratio in select key, (value::float8) from jsonb_each_text(rec.elements) loop
    sum_ratio := sum_ratio + ratio;
  end loop;
  if sum_ratio <= 0 then
    return jsonb_build_object('status', 'error', 'message', 'Invalid recipe elements');
  end if;

  for elem, ratio in select key, (value::float8) from jsonb_each_text(rec.elements) loop
    amt := greatest(0, round((batch_total * ratio / sum_ratio)::numeric, 6));
    elements_out := elements_out || jsonb_build_object(elem, amt);
    insert into user_materials (user_id, element, amount)
    values (uid, elem, amt)
    on conflict (user_id, element) do update set amount = user_materials.amount + amt;
  end loop;

  -- 스톤 차감
  update profiles
  set minerals = jsonb_set(minerals, '{stone}', to_jsonb(greatest(0, (minerals->>'stone')::int - 100)))
  where id = uid;
  select (minerals->>'stone')::int into stone_bal from profiles where id = uid;

  return jsonb_build_object(
    'status', 'success',
    'mineral_name', rec.name,
    'elements', elements_out,
    'current_stone', stone_bal
  );
end;
$$;

----------------------------------------------------------------------------
-- [9] RLS (보안 정책)
----------------------------------------------------------------------------

alter table public.profiles enable row level security;
alter table public.mineral_recipes enable row level security;
alter table public.user_materials enable row level security;
alter table public.stones enable row level security;
alter table public.shared_stones enable row level security;
alter table public.stone_likes enable row level security;

alter table public.profiles force row level security;
alter table public.mineral_recipes force row level security;
alter table public.user_materials force row level security;
alter table public.stones force row level security;
alter table public.shared_stones force row level security;
alter table public.stone_likes force row level security;

-- 기존 정책 제거 (재실행 대비)
drop policy if exists "profiles_select_public" on public.profiles;
drop policy if exists "profiles_update_own" on public.profiles;
drop policy if exists "recipes_select_public" on public.mineral_recipes;
drop policy if exists "user_materials_select_own" on public.user_materials;
drop policy if exists "user_materials_write_own" on public.user_materials;
drop policy if exists "stones_select_own" on public.stones;
drop policy if exists "stones_write_own" on public.stones;
drop policy if exists "shared_stones_select_public" on public.shared_stones;
drop policy if exists "shared_stones_insert_own" on public.shared_stones;
drop policy if exists "shared_stones_update_own" on public.shared_stones;
drop policy if exists "shared_stones_delete_own" on public.shared_stones;
drop policy if exists "stone_likes_select_public" on public.stone_likes;
drop policy if exists "stone_likes_insert_own" on public.stone_likes;
drop policy if exists "stone_likes_delete_own" on public.stone_likes;

create policy "profiles_select_public"
  on public.profiles for select
  using (true);

create policy "profiles_update_own"
  on public.profiles for update
  using (auth.uid() = id)
  with check (auth.uid() = id);

create policy "recipes_select_public"
  on public.mineral_recipes for select
  using (true);

create policy "user_materials_select_own"
  on public.user_materials for select
  using (auth.uid() = user_id);

create policy "user_materials_write_own"
  on public.user_materials for all
  using (auth.uid() = user_id)
  with check (auth.uid() = user_id);

create policy "stones_select_own"
  on public.stones for select
  using (auth.uid() = owner_id);

create policy "stones_write_own"
  on public.stones for all
  using (auth.uid() = owner_id)
  with check (auth.uid() = owner_id);

create policy "shared_stones_select_public"
  on public.shared_stones for select
  using (is_deleted = false);

create policy "shared_stones_insert_own"
  on public.shared_stones for insert
  with check (auth.uid() = owner_id);

create policy "shared_stones_update_own"
  on public.shared_stones for update
  using (auth.uid() = owner_id)
  with check (auth.uid() = owner_id);

create policy "shared_stones_delete_own"
  on public.shared_stones for delete
  using (auth.uid() = owner_id);

create policy "stone_likes_select_public"
  on public.stone_likes for select
  using (true);

create policy "stone_likes_insert_own"
  on public.stone_likes for insert
  with check (auth.uid() = user_id);

create policy "stone_likes_delete_own"
  on public.stone_likes for delete
  using (auth.uid() = user_id);